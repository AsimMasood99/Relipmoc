use crate::lexer::tokens::Token;


    // defining some aliases
pub type RootList = Vec<Root>;
// pub type Type = Token; // {Int,String,Float,Bool}
// this Token will be defined in the lexer and used here as type so we dont need to define type again


#[derive(Debug)]
pub enum Root{
    Var(VariableDeclaration),
    Func(FunctionStatement),
}

#[derive(Debug)]
pub struct VariableDeclaration{ // for declaration of variables
    pub type_token: Token,
    pub identifier: String,
    pub expression: Expr,
}

#[derive(Debug)]
pub struct FunctionStatement{
    pub type_token: Token,
    pub identifier: String,
    // left curly braces
    pub params: Vec<Param>, // we are handeling params as vector of params
    // right curly braces
    pub block: Block,
}


// #[derive(Debug)]
// pub enum function_type{
//     pub type_token: Type,
// }

// RENOTE: params are being handeled as vector of strings for now (inside function_statement structs)

#[derive(Debug)]
pub struct Param{
    pub type_token: Token,
    pub identifier: String,
}

#[derive(Debug)]
pub struct Block{
    // left curly braces
    pub statements: Vec<Statement>, // "statements . statements"
    // right curly braces
}

// language of statements are handeled in the Block struct

#[derive(Debug)]
pub enum Statement{
    If(IfStatement),
    // While(while_statement),
    For(ForStatement),
    Var(VariableDeclaration),
    Expr(ExpressionStatement),
    Break,
    Continue,
    Return(ReturnStatement),
    Block(Block), // nested block
}

#[derive(Debug)]
pub struct ForStatement{
    // T_FOR,
    // left parenthesis
    pub init_loop_var: Option<VariableDeclaration>, // Option enum allows absence of values
    pub loop_condition: ExpressionStatement,
    pub update_loop_var: Option<expression>, // just a simple number as expression (j++, ++j)
    pub block:Block
}

#[derive(Debug)]
pub enum InitLoopVar{
    Var(VariableDeclaration),
    // semi colon // TODO: check is this approach correct as semi colon is a  
}

// update-loop-var taken care of in the for_statement struct

#[derive(Debug)]
pub struct IfStatement{
    // T_IF,
    pub if_statement: IfStatementExpression,
    pub elif_statement: Vec<ElifStatement>,
    //else 
    pub else_statement: Option<Block>, 
}

#[derive(Debug)]
pub struct IfStatementExpression{
    // if
    // left round bracket
    pub condition: Expr,
    // right round bracket
    block: Block
}

#[derive(Debug)]
pub enum ElifStatement{
    Elif{
        // T_ELSE_IF,
        if_statement: IfStatementExpression,
        elif_statement: Option<Box<ElifStatement>>, // To allocate memory on heap for recursive elif statements
        // right curly bracket
    }
}

// else-statement taken care of in the if_statement struct

#[derive(Debug)]
pub struct ReturnStatement{
    // T_RETURN,
    pub expr: ExpressionStatement,
}

// break and continue dont need separate structs

#[derive(Debug)]
pub enum ExpressionStatement{
    Expr(Expr),
    SemiColon, // to handle empty expression statements
}

#[derive(Debug)]
pub enum AssignmentExpression{
        Boolean(BooleanExpression),
        Assigning(
            BooleanExpression,
            // assignment_operator // =,+=,-=,*=,/=,%= (terminal in lexer)
            Box<AssignmentExpression> // recursive to allow chaining of assignments
        )
}

#[derive(Debug)]
pub enum BooleanExpression{
    BitwiseOr(BitOrExpression),
    Or(
        BitOrExpression,
        // T_OR, // terminal in lexer
        Box<BooleanExpression> // recursive to allow chaining of 'or' operations
    )
}

# [derive(Debug)]
pub enum BitOrExpression{
    BitwiseAnd(BitAndExpression),
    BitOr(
        BitAndExpression,
        // T_AND, // terminal in lexer
        Box<BitOrExpression> // recursive to allow chaining of 'and' operations
    )
}

# [derive(Debug)]
pub enum BitAndExpression{
    Compare(CompareExpression),
    BitAnd(
        CompareExpression,
        // comparison_operator, // <,>,<=,>=,==,!= (terminal in lexer)
        Box<BitAndExpression> // recursive to allow chaining of comparison operations
    )
}


# [derive(Debug)]
pub enum CompareExpression{
    Shift(ShiftExpression),
    Compare(
        ShiftExpression,
        comparison_operator, // <,>,<=,>=,==,!= (terminal in lexer)
        Box<CompareExpression> // recursive to allow chaining of comparison operations
    )
}

# [derive(Debug)]
pub enum ShiftExpression{
    Addition(AdditionExpression),
    Shift(
        AdditionExpression,
        shift_operator, // <<,>>   (terminal in lexer)
        Box<ShiftExpression> // recursive to allow chaining of shift operations
    )
} 

# [derive(Debug)]   
pub enum AdditionExpression{
    Multiplication(MultiplicationExpression),
    Add(
        MultiplicationExpression,
        addition_operator, // +,-   (terminal in lexer)
        Box<AdditionExpression> // recursive to allow chaining of addition operations
    )
}

# [derive(Debug)]
pub enum MultiplicationExpression{
    Unary(UnaryExpression),
    Multiply(
        UnaryExpression,
        MultiplicationOperator, // *,/,%,   (terminal in lexer)
        Box<MultiplicationExpression> // recursive to allow chaining of multiplication operations
    )
}

# [derive(Debug, Clone)]
pub enum MultiplicationOperator {
    Multiply,  // *
    Divide,    // /
    Modulo,    // %
}

# [derive(Debug)]
pub enum ExpExpression{
    Unary(UnaryExpression),
    Exp(
        UnaryExpression,
        exp_operator, // **   (terminal in lexer)
        Box<ExpExpression> // recursive to allow chaining of exp operations
    )
}


# [derive(Debug)]
pub enum UnaryExpression{
    Primary(PrimaryExpression),
    UnaryOp(
        UnaryOperator, // !,~,++,--,+,-   (terminal in lexer)
        Box<UnaryExpression> // recursive to allow chaining of unary operations
    )
}


# [derive(Debug, Clone)]
pub enum UnaryOperator {
    Minus,  // -
    Not,    // !
}


// TODO: is this the primary_expression correct

#[derive(Debug)]
pub enum PrimaryExpression{
    Literal(Literal), // int, float, string, bool
    Identifier(String), // variable name
    FuncCall(FunctionCall),
    // (expression)
    Expr(Box<Expr>), // Box to allocate memory on heap for recursive expressions
}

// #[derive(Debug)]
// pub enum primary_expression {
//     ConstInt(i64),      // T_CONST_INT
//     ConstFloat(f64),    // T_CONST_FLOAT 
//     StringLit(String),  // T_STRINGLIT
//     BoolLit(bool),      // bool-literal
//     Identifier(String), // T_IDENTIFIER
//     ParenExpr(Box<Expr>), // T_ROUND_BRACKET_OPEN expr T_ROUND_BRACKET_CLOSE
//     FuncCall(function_call) // function-call
// }


// bool-literal

#[derive(Debug)]
pub enum BoolLiteral {
    True,
    False,
}

#[derive(Debug)]
pub struct FunctionCall{
    pub identifier: String, // function name
    // left round bracket
    pub args: Vec<Expr>, // Vec handles zero, one, or many arguments
    // right round bracket
}
